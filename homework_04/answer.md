# Архитектура проекта `homework_04`

## Структура папок и файлов

homework_04/
│
├─ main.py # Примеры использования всех хранилищ и файлов
│
├─ model/
│ ├─ media/
│ │ ├─ __init__.py
│ │ ├─ audio_file.py
│ │ ├─ base_audio_video_stream_file.py
│ │ ├─ base_media_file.py
│ │ ├─ file_registry.py # Фабрика create_file_from_metadata
│ │ ├─ photo_file.py
│ │ └─ video_file.py
│ │
│ └─ storage/
│ ├─ base_remote_storage.py
│ ├─ base_storage.py
│ ├─ cloud_storage.py
│ ├─ ftp_storage.py
│ └─ local_storage.py


> Пример использования всех типов файлов и хранилищ можно смотреть в `main.py` в корне `homework_04`.

---

# Добавление новых типов файлов и способов хранения

Если использовать предложенную архитектуру с **фабрикой (`create_file_from_metadata`)** и разделением ответственности между хранилищами и файлами, то при добавлении новых типов файлов или способов хранения **почти ничего не нужно переписывать**.  

---

## 1️⃣ Добавление нового типа файла

Допустим, нужно добавить `DocumentFile`:

- Создаём новый класс `DocumentFile(BaseMediaFile)` и определяем его специфичные свойства и методы (`get_metadata`, `convert`, и т.д.).
- Регистрируем его в **фабрике `create_file_from_metadata`**, чтобы метод `load` знал, какой класс создавать по метаданным (`type="document"`).

✅ После этого **ни один хранилищный класс менять не нужно** — `load` автоматически вернёт объект `DocumentFile` при наличии соответствующих метаданных.

---

## 2️⃣ Добавление нового способа хранения

Например, облачное хранилище S3 или сетевой диск:

- Создаём новый класс-наследник `BaseRemoteStorage` (или `BaseStorage` для локальных), реализуем:  
  - `connect()` / `disconnect()`  
  - `save(file)` / `delete(file)`  
  - `fetch_metadata(file_id)`  

- **Метод `load` наследуется** из базового класса, использует фабрику и возвращает объект нужного типа.

✅ Не нужно переписывать существующие хранилища, фабрику или сами классы файлов.

---

## 3️⃣ Почему архитектура экономит код

- `BaseStorage` / `BaseRemoteStorage` **содержат общую логику `load` через фабрику**.  
- Хранилища отвечают только за доступ к данным (`save`, `delete`, `fetch_metadata`).  
- Файлы сами знают свои свойства и метаданные.  
- Новые типы файлов требуют только добавления класса + регистрации в фабрике, **без изменений хранилищ**.  

---

## 4️⃣ Вывод

- **Много кода не нужно дописывать**, структура очень расширяемая.  
- Новые типы файлов и хранилища подключаются минимальными усилиями.  
- Архитектура соблюдает принципы **OCP (Open/Closed Principle)**: открыто для расширения, закрыто для изменения.
